# src/MajiJl.jl

"""
    MagiJl

MAnifold-constrained Gaussian process Inference (MAGI) in Julia.
"""
module MagiJl

# =========
# External Dependencies
# =========
using LinearAlgebra
using KernelFunctions
using BandedMatrices
using PositiveFactorizations
using LogDensityProblems
using AdvancedHMC
using Logging
using Statistics # For var, median, abs, mean
using Optim      # For initialization optimization
using Printf     # For formatted printing in summary

# Optional Dependencies for Postprocessing (Load if available)
using Requires
@static if !isdefined(Base, :get_extension)
    using Requires # Ensure Requires is loaded for Julia < 1.9
end

# Define placeholder functions if packages are not loaded
function __init__()
    @static if !isdefined(Base, :get_extension)
        # Conditional loading for Julia < 1.9
        @require Plots="91a5bcdd-55d7-5caf-9e0b-520d859cae80" begin
            @require StatsPlots="f3b207a7-027a-5e70-b257-86293d7955fd" begin
                 @info "Plots and StatsPlots loaded."
            end
        end
        @require MCMCChains="c7f686f2-ff18-58e9-bbe5-17545b1d6079" begin
             @info "MCMCChains loaded."
        end
    end
end

# Function to safely check if a package is loaded and usable
macro isloaded(pkg)
    return :(isdefined(Main, $(QuoteNode(pkg))) && isa(getfield(Main, $(QuoteNode(pkg))), Module))
end


# =========
# Includes: Order matters if files depend on each other
# =========
include("ode_models.jl")
include("kernels.jl")
include("gaussian_process.jl")
include("likelihoods.jl")
include("logdensityproblems_interface.jl")
include("samplers.jl")
include("initialization.jl")
# include("postprocessing.jl") # REMOVED - code integrated below

# =========
# Usings: Bring submodules into the main MagiJl scope
# =========
using .ODEModels
using .Kernels
using .GaussianProcess
using .Likelihoods
using .LogDensityProblemsInterface
using .Samplers
using .Initialization
# using .Postprocessing     # REMOVED

# =========
# Exports: Make functions/types available to users via 'using MagiJl'
# =========

# From ode_models.jl
export OdeSystem
export fn_ode!, hes1_ode!, hes1log_ode!, hes1log_ode_fixg!, hes1log_ode_fixf!, hiv_ode!, ptrans_ode!
export fn_ode_dx!, fn_ode_dtheta, hes1_ode_dx!, hes1_ode_dtheta

# From kernels.jl
export create_rbf_kernel, create_matern52_kernel, create_general_matern_kernel

# From gaussian_process.jl
export GPCov, calculate_gp_covariances!

# From likelihoods.jl
export log_likelihood_and_gradient_banded

# From LogDensityProblemsInterface
export MagiTarget

# From Samplers
export run_nuts_sampler

# Main solver function
export solve_magi

# From Postprocessing (Now defined directly in this module)
export magi_summary, plot_magi, results_to_chain

# =========================================================================
# solve_magi function definition
# =========================================================================
"""
    solve_magi(y_obs, t_obs, ode_system, config; ...)
Main function to run the MAGI algorithm.
... (docstring remains the same) ...
"""
function solve_magi(
    y_obs::Matrix{Float64},
    t_obs::Vector{Float64},
    ode_system::OdeSystem,
    config::Dict{Symbol,Any}=Dict{Symbol,Any}();
    initial_params=nothing
)
    # --- Implementation of solve_magi ---
    @info "Starting MAGI solver..."
    println("Input Data: $(size(y_obs, 1)) time points, $(size(y_obs, 2)) dimensions.")
    println("Time points from $(minimum(t_obs)) to $(maximum(t_obs)).")
    println("Using ODE System with $(ode_system.thetaSize) parameters.")
    println("Config: ", config) # Be careful if config contains large xInit

    # --- 1 & 2: Extract Info & Config ---
    kernel_type = get(config, :kernel, "matern52")
    niter_hmc = get(config, :niterHmc, 20000)
    burnin_ratio = get(config, :burninRatio, 0.5)
    step_size_factor = get(config, :stepSizeFactor, 0.01)
    band_size = get(config, :bandSize, 20)
    prior_temperature = get(config, :priorTemperature, [1.0, 1.0, 1.0])
    sigma_exogenous = get(config, :sigma, Float64[])
    phi_exogenous = get(config, :phi, Matrix{Float64}(undef, 0, 0))
    x_init_exogenous = get(config, :xInit, Matrix{Float64}(undef, 0, 0))
    theta_init_exogenous = get(config, :thetaInit, Float64[])
    target_accept_ratio = get(config, :targetAcceptRatio, 0.8)
    jitter = get(config, :jitter, 1e-6)

    # Dimensions
    n_times = length(t_obs)
    n_dims = size(y_obs, 2)
    n_params_ode = ode_system.thetaSize

    # --- 3. Initialize GP Hyperparameters (phi) & Observation Noise (sigma) ---
    local phi_all_dimensions::Matrix{Float64}
    local sigma::Vector{Float64}

    if isempty(phi_exogenous) || isempty(sigma_exogenous)
        println("Optimizing GP hyperparameters (phi and sigma) using marginal likelihood...")
        phi_all_dimensions = zeros(2, n_dims)
        sigma = zeros(n_dims)
        optim_opts = Optim.Options(
            iterations = get(config, :gpOptimIterations, 100),
            show_trace = get(config, :gpOptimShowTrace, false),
            f_tol = get(config, :gpOptimFTol, 1e-8),
            g_tol = get(config, :gpOptimGTol, 1e-8)
        )

        for dim in 1:n_dims
            println("  Optimizing dimension $dim...")
            y_dim = y_obs[:, dim]
            log_var_guess, log_len_guess, log_sigma_guess = 0.0, 0.0, 0.0
            valid_y = filter(!isnan, y_dim)
            if !isempty(valid_y) && length(valid_y) > 1
                var_y = var(valid_y; corrected=true)
                data_range = maximum(valid_y) - minimum(valid_y)
                time_range = maximum(t_obs) - minimum(t_obs)
                mad_val = median(abs.(valid_y .- median(valid_y))) * 1.4826
                log_var_guess = log(max(var_y, 1e-4))
                log_len_guess = log(max(time_range / 10.0, 1e-2))
                log_sigma_guess = log(max(mad_val, 1e-3 * data_range, 1e-4))
            else
                log_var_guess = log(1.0)
                log_len_guess = log(max((maximum(t_obs) - minimum(t_obs)) / 10.0, 1e-2))
                log_sigma_guess = log(0.1)
            end
            initial_log_params = [log_var_guess, log_len_guess, log_sigma_guess]
            println("    Initial guess [log(var), log(len), log(sigma)]: ", round.(initial_log_params, digits=3))

            optimized_params = Initialization.optimize_gp_hyperparameters(
                y_dim, t_obs, kernel_type, initial_log_params;
                jitter=jitter, optim_options=optim_opts
            )
            println("    Optimized [var, len, sigma]: ", round.(optimized_params, digits=4))

            phi_all_dimensions[1, dim] = optimized_params[1]
            phi_all_dimensions[2, dim] = optimized_params[2]
            sigma[dim] = optimized_params[3]
        end
        println("Optimization complete.")

    elseif isempty(phi_exogenous) && !isempty(sigma_exogenous)
         error("If providing :sigma exogenously, must also provide :phi.")
    elseif !isempty(phi_exogenous) && isempty(sigma_exogenous)
         error("If providing :phi exogenously, must also provide :sigma.")
    else
         if size(phi_exogenous) != (2, n_dims)
             error("Provided :phi matrix has wrong dimensions. Expected (2, $n_dims), got $(size(phi_exogenous)).")
         end
         if length(sigma_exogenous) != n_dims
             error("Provided :sigma vector has wrong length. Expected $n_dims, got $(length(sigma_exogenous)).")
         end
         phi_all_dimensions = phi_exogenous
         sigma = sigma_exogenous
     end
    println("Using phi (GP hyperparameters):\n", round.(phi_all_dimensions, digits=4))
    println("Using sigma (observation noise SD): ", round.(sigma, digits=4))

    # --- 3. Initialize Latent States (x) ---
    local x_init::Matrix{Float64}
    if isempty(x_init_exogenous)
        x_init = zeros(n_times, n_dims)
        for dim in 1:n_dims
            valid_indices = findall(!isnan, y_obs[:, dim])
            if isempty(valid_indices)
                x_init[:, dim] .= 0.0
                @warn "No observations found for dimension $dim. Initializing x with zeros."
                continue
            end
            valid_times = t_obs[valid_indices]
            valid_values = y_obs[valid_indices, dim]
            for i in 1:n_times
                t = t_obs[i]
                if t <= valid_times[1]
                    x_init[i, dim] = valid_values[1]
                elseif t >= valid_times[end]
                    x_init[i, dim] = valid_values[end]
                else
                    idx_lower = findlast(valid_times .<= t)
                    if idx_lower === nothing # Should not happen if t > valid_times[1]
                        x_init[i, dim] = valid_values[1] # Fallback
                        continue
                    end
                    if t == valid_times[idx_lower]
                         x_init[i, dim] = valid_values[idx_lower]
                         continue
                    end
                    idx_upper = idx_lower + 1
                    if idx_upper > length(valid_times)
                        x_init[i, dim] = valid_values[end] # Should be idx_lower? Check logic
                        continue
                    end
                    t_lower = valid_times[idx_lower]
                    t_upper = valid_times[idx_upper]
                    v_lower = valid_values[idx_lower]
                    v_upper = valid_values[idx_upper]
                    if t_upper == t_lower
                         x_init[i, dim] = v_lower # Or average?
                    else
                         weight = (t - t_lower) / (t_upper - t_lower)
                         x_init[i, dim] = (1 - weight) * v_lower + weight * v_upper
                    end
                end
            end
        end
    else
         if size(x_init_exogenous) != (n_times, n_dims)
             error("Provided :xInit matrix has wrong dimensions. Expected ($n_times, $n_dims), got $(size(x_init_exogenous)).")
         end
        x_init = x_init_exogenous
    end

    # --- 3. Initialize ODE Parameters (theta) ---
    local theta_init::Vector{Float64}
    if isempty(theta_init_exogenous)
        theta_init = zeros(n_params_ode)
        for i in 1:n_params_ode
            lb = ode_system.thetaLowerBound[i]
            ub = ode_system.thetaUpperBound[i]
            if isfinite(lb) && isfinite(ub)
                theta_init[i] = (lb + ub) / 2.0
            elseif isfinite(lb)
                theta_init[i] = lb + abs(lb)*0.1 + 0.1 # Avoid being exactly on boundary
            elseif isfinite(ub)
                theta_init[i] = ub - abs(ub)*0.1 - 0.1 # Avoid being exactly on boundary
            else
                theta_init[i] = 0.0 # Default guess
            end
             # Ensure guess is strictly within bounds if possible
             if isfinite(lb) && theta_init[i] <= lb
                 theta_init[i] = lb + 1e-4 # Small nudge
             end
             if isfinite(ub) && theta_init[i] >= ub
                 theta_init[i] = ub - 1e-4 # Small nudge
             end
             theta_init[i] = clamp(theta_init[i], lb, ub) # Final clamp for safety
        end
    else
         if length(theta_init_exogenous) != n_params_ode
             error("Provided :thetaInit vector has wrong length. Expected $n_params_ode, got $(length(theta_init_exogenous)).")
         end
        theta_init = theta_init_exogenous
        if any(theta_init .< ode_system.thetaLowerBound) || any(theta_init .> ode_system.thetaUpperBound)
             @warn "Provided :thetaInit contains values outside the specified bounds. Clamping initial values."
             theta_init = clamp.(theta_init, ode_system.thetaLowerBound, ode_system.thetaUpperBound)
        end
    end
    println("Initial theta: ", round.(theta_init, digits=4))

    # --- 4. Calculate GPCov Structs ---
    @info "Calculating GP Covariance structures..."
    cov_all_dimensions = Vector{GPCov}(undef, n_dims)
    actual_band_size = min(band_size, n_times - 1) # Ensure band size isn't too large
     if actual_band_size < 0
        actual_band_size = 0 # Handle n_times=1 case
    end
    println("Using Band Size: $actual_band_size (Requested: $band_size)")
    for dim in 1:n_dims
        cov_all_dimensions[dim] = GPCov()
        local kernel # Ensure kernel is defined in this scope
        phi_dim = phi_all_dimensions[:, dim]
        var = phi_dim[1]
        len = phi_dim[2]
        if kernel_type == "matern52"
            kernel = Kernels.create_matern52_kernel(var, len)
        elseif kernel_type == "rbf"
            kernel = Kernels.create_rbf_kernel(var, len)
        else
            @warn "Unsupported kernel type '$kernel_type'. Defaulting to matern52."
            kernel = Kernels.create_matern52_kernel(var, len)
        end
        try
             calculate_gp_covariances!(
                 cov_all_dimensions[dim], kernel, phi_dim, t_obs, actual_band_size;
                 complexity=2, jitter=jitter
             )
        catch e
             @error "Failed to calculate GP covariances for dimension $dim." phi=phi_dim kernel=kernel bandsize=actual_band_size jitter=jitter
             rethrow(e)
         end
    end
    @info "GP Covariance calculation complete."

    # --- 5. Define Log Posterior Target ---
    if !(typeof(prior_temperature) <: AbstractVector && length(prior_temperature) == 3)
         @warn "priorTemperature should be a vector of 3 floats [Deriv, Level, Obs]. Using default [1.0, 1.0, 1.0] or first element if scalar."
         scalar_temp = first(prior_temperature) # Take first element if it's a scalar/vector
         prior_temps = fill(Float64(scalar_temp), 3)
    else
         prior_temps = convert(Vector{Float64}, prior_temperature)
    end
    println("Using Prior Temperatures [Deriv, Level, Obs]: ", prior_temps)
    target = MagiTarget(
        y_obs, cov_all_dimensions, ode_system.fOde, ode_system.fOdeDx, ode_system.fOdeDtheta,
        sigma, prior_temps, n_times, n_dims, n_params_ode
    )

    # --- 6. Initialize Full Parameter Vector for Sampler ---
    local params_init::Vector{Float64}
    if initial_params === nothing
        params_init = vcat(vec(x_init), theta_init)
    else
         if length(initial_params) != (n_times * n_dims + n_params_ode)
             error("Provided initial_params vector has wrong length. Expected $(n_times * n_dims + n_params_ode), got $(length(initial_params)).")
         end
        params_init = initial_params
        # Check bounds for theta part of provided initial_params
        theta_part_init = initial_params[(n_times * n_dims + 1):end]
         if any(theta_part_init .< ode_system.thetaLowerBound) || any(theta_part_init .> ode_system.thetaUpperBound)
             @warn "Theta part of provided initial_params contains values outside bounds. Sampler might struggle or reject states."
         end
    end
    total_params_dim = length(params_init)
    println("Total number of parameters being sampled: $total_params_dim")

    # --- 7. Run Sampler ---
    @info "Setting up and running NUTS sampler..."
    n_adapts = Int(floor(niter_hmc * burnin_ratio))
    n_samples_total = niter_hmc
    n_samples_keep = n_samples_total - n_adapts # Samples after warmup
    initial_step_size = step_size_factor

    # Initialize chain and stats outside try block
    local chain = nothing
    local stats = nothing

    try
        chain, stats = run_nuts_sampler(
            target, params_init; n_samples = n_samples_total, n_adapts = n_adapts,
            target_accept_ratio = target_accept_ratio, initial_step_size = initial_step_size
        )
    catch sampler_err
        @error "Error occurred during run_nuts_sampler call." exception=(sampler_err, catch_backtrace())
        # Ensure chain/stats remain nothing or handle appropriately
        chain = nothing
        stats = nothing
        # Decide whether to rethrow or let the checks below handle it
        # rethrow(sampler_err) # Option: Stop execution immediately
    end

    # +++ ADDED DEBUG PRINTS HERE +++
    println("--- solve_magi DEBUG: Sampler returned. ---")
    println("--- solve_magi DEBUG: Type of chain: $(typeof(chain))")
    if chain !== nothing
        println("--- solve_magi DEBUG: Chain Is empty: $(isempty(chain)), Length: $(length(chain)) ---")
    end
    println("--- solve_magi DEBUG: Type of stats: $(typeof(stats))")
     if stats !== nothing
        println("--- solve_magi DEBUG: Stats Is empty: $(isempty(stats)), Length: $(try length(stats) catch; -1 end) ---")
    end
    # +++++++++++++++++++++++++++++++


    # Check if sampling failed (chain is nothing or empty)
    if chain === nothing || isempty(chain)
        # Critical failure in sampler execution or it returned nothing
        @error "Sampling failed or returned no samples. Check sampler logs or errors."
        # Depending on desired behavior, either throw an error or return something indicative of failure
        # Option 1: Throw error
        error("Sampling failed or returned no samples.")
        # Option 2: Return nothing (less informative upstream)
        # return nothing
    end
    @info "Sampling completed." # Indicates sampler ran and returned *something*


    # --- 8. Process Results ---
    @info "Processing MCMC samples..."
    println("--- solve_magi DEBUG: Entering results processing block. ---")

    local samples_post_burnin_matrix, x_samples, theta_samples, lp_values
    try
        # Ensure chain is a Vector of Vectors
        if !(chain isa Vector) || (length(chain)>0 && !(first(chain) isa AbstractVector))
             error("Sampler output 'chain' is not a Vector of Vectors as expected. Type: $(typeof(chain))")
        end

        samples_post_burnin_matrix = hcat(chain...) # This assumes chain is vector of vectors
        println("--- solve_magi DEBUG: samples_post_burnin_matrix size: $(size(samples_post_burnin_matrix)) ---")

        n_samples_post_burnin = size(samples_post_burnin_matrix, 2)

        # Check if the number of samples matches expectation (samples - adapts)
        if n_samples_post_burnin != n_samples_keep
             @warn "Number of samples after warmup ($(n_samples_post_burnin)) does not match expected ($(n_samples_keep)). Check sampler's drop_warmup setting or output."
             # Proceeding, but this might indicate an issue.
             if n_samples_post_burnin == 0
                 error("Sampler returned no post-burn-in samples after hcat.")
             end
        end

        x_indices = 1:(n_times * n_dims)
        theta_indices = (n_times * n_dims + 1):(total_params_dim)

        x_samples_flat = samples_post_burnin_matrix[x_indices, :]
        x_samples = Array{Float64, 3}(undef, n_samples_post_burnin, n_times, n_dims)
        println("--- solve_magi DEBUG: Initialized x_samples array size: $(size(x_samples)) ---")

        for i in 1:n_samples_post_burnin
            x_samples[i, :, :] = reshape(view(x_samples_flat, :, i), n_times, n_dims) # Use view for efficiency
        end
        println("--- solve_magi DEBUG: Reshaped x_samples successfully. ---")


        theta_samples = Matrix(samples_post_burnin_matrix[theta_indices, :]')
        println("--- solve_magi DEBUG: Created theta_samples matrix size: $(size(theta_samples)) ---")

        lp_values = Float64[] # Initialize as empty
        println("--- solve_magi DEBUG: Attempting to extract lp_values... ---")
        # Check stats structure BEFORE trying to access elements
        if stats !== nothing && stats isa Vector && !isempty(stats)
             # Check if length matches the number of *returned* samples
             if length(stats) == n_samples_post_burnin
                 first_stat = first(stats)
                 println("--- solve_magi DEBUG: stats[1] type: $(typeof(first_stat)), fields: $(try fieldnames(typeof(first_stat)) catch; "N/A" end) ---")
                 if hasproperty(first_stat, :lp)
                     lp_values = [s.lp for s in stats]
                     println("--- solve_magi DEBUG: Extracted lp_values using :lp field. Length: $(length(lp_values)) ---")
                 elseif hasproperty(first_stat, :log_density)
                     lp_values = [s.log_density for s in stats]
                     println("--- solve_magi DEBUG: Extracted lp_values using :log_density field. Length: $(length(lp_values)) ---")
                 else
                     @warn "Sampler statistics vector does not contain :lp or :log_density field."
                     println("--- solve_magi DEBUG: Could not find :lp or :log_density in stats objects.")
                 end
             else
                  @warn "Length of stats ($(length(stats))) does not match number of post-burn-in samples ($(n_samples_post_burnin)). Cannot reliably extract lp values."
                  println("--- solve_magi DEBUG: Stats length mismatch, cannot extract lp_values.")
             end
        else
             stats_type = typeof(stats)
             stats_len = try length(stats) catch; -1 end # Handle cases where length() is not defined
             @warn "Log posterior values could not be extracted. Stats structure unexpected (Type: $stats_type, Length: $stats_len, Expected: Vector of length $n_samples_post_burnin)."
             println("--- solve_magi DEBUG: Stats structure unexpected or mismatch, cannot extract lp_values.")
        end
        @info "Finished processing results."

    catch process_err
        @error "Error during results processing block!" exception=(process_err, catch_backtrace())
        # Decide how to handle processing errors
        # Option 1: Rethrow the error
        rethrow(process_err)
        # Option 2: Return an indicator of partial failure (e.g., return nothing)
        # return nothing
    end


    # +++ ADDED DEBUG PRINT BEFORE RETURN +++
    println("--- solve_magi DEBUG: Preparing to return NamedTuple... ---")
    # +++++++++++++++++++++++++++++++++++++

    # Ensure all variables are defined before returning
    if !@isdefined(theta_samples) || !@isdefined(x_samples) || !@isdefined(lp_values)
         @error "Results processing did not complete successfully, cannot return standard output."
         # Handle this case, maybe return nothing or throw error
         return nothing # Example: return nothing to indicate failure
    end

    # Return the successfully processed results
    return (
        theta = theta_samples, x_sampled = x_samples,
        sigma = reshape(sigma, 1, n_dims), phi = phi_all_dimensions, lp = lp_values
    )

end # end solve_magi


# =========================================================================
# Postprocessing Functions (Integrated from postprocessing.jl)
# =========================================================================

"""
    results_to_chain(results::NamedTuple; par_names=nothing, include_sigma=false, include_lp=false)

Convert the theta samples (and optionally sigma, lp) from MagiSolver results
into an MCMCChains.Chains object. Requires MCMCChains to be loaded.
"""
function results_to_chain(results::NamedTuple; par_names=nothing, include_sigma=false, include_lp=false)
    if !@isloaded(MCMCChains)
         error("MCMCChains package is required for results_to_chain function. Please install and load it (`using MCMCChains`).")
    end

    # Access MCMCChains functions using getfield
    Chains = getfield(Main, :MCMCChains).Chains

    theta_samples = results.theta
    n_samples, n_params_ode = size(theta_samples)

    # --- Parameter names ---
    # Start with theta names
    if par_names === nothing
        _par_names_vec = ["theta[$i]" for i in 1:n_params_ode]
    else
        # Check length ONLY for the theta part
        if length(par_names) != n_params_ode
            error("Length of provided par_names ($(length(par_names))) does not match number of theta parameters ($n_params_ode).")
        end
        _par_names_vec = copy(par_names) # Use a copy to avoid modifying the input
    end

    # Data matrix for MCMCChains (samples x parameters x chains)
    # Start with theta data
    data_matrix = theta_samples

    # Add sigma if requested
    if include_sigma
        sigma_samples = vec(results.sigma) # Should be fixed, so repeat it
        n_dims = length(sigma_samples)
        sigma_matrix = repeat(reshape(sigma_samples, 1, n_dims), n_samples, 1)
        data_matrix = hcat(data_matrix, sigma_matrix)
        # Add sigma names AFTER theta names
        sigma_names = ["sigma[$i]" for i in 1:n_dims]
        append!(_par_names_vec, sigma_names)
    end

    # Add log-posterior if requested
    # Check if lp exists and is not empty
    if include_lp && haskey(results, :lp) && !isempty(results.lp)
        lp_samples = results.lp
        if length(lp_samples) == n_samples
            data_matrix = hcat(data_matrix, lp_samples)
            # Add lp name AFTER theta and sigma names
            push!(_par_names_vec, "lp")
        else
            @warn "Length of log-posterior (:lp) samples ($(length(lp_samples))) does not match number of theta samples ($n_samples). Cannot include lp in chain."
        end
    elseif include_lp
         @warn "Log-posterior (:lp) key not found or vector is empty in results. Cannot include lp in chain."
    end

    # Convert final list of string names to Symbols for MCMCChains
    _par_names_symbols = Symbol.(_par_names_vec)

    # Create the Chains object
    # MCMCChains expects data in [iterations, parameters, chains]
    chains_data = reshape(data_matrix, n_samples, size(data_matrix, 2), 1)
    chn = Chains(chains_data, _par_names_symbols) # Use Symbols

    return chn
end


"""
    magi_summary(results::NamedTuple; par_names=nothing, include_sigma=false, digits=3, lower=0.025, upper=0.975)

Compute summary statistics (mean, median, quantiles, etc.) for the MCMC samples.
Requires MCMCChains to be loaded for full summary.
"""
function magi_summary(results::NamedTuple; par_names=nothing, include_sigma=false, digits=3, lower=0.025, upper=0.975)
    println("--- MAGI Posterior Summary ---")

    if !@isloaded(MCMCChains)
        @warn "MCMCChains not available. Printing basic mean/median."
        theta_mean = mean(results.theta, dims=1)
        theta_median = median(results.theta, dims=1)
        println("Theta Mean: ", round.(vec(theta_mean); digits=digits))
        println("Theta Median: ", round.(vec(theta_median); digits=digits))
        if include_sigma
             println("Sigma (Fixed/Optimized): ", round.(vec(results.sigma); digits=digits))
        end
        return nothing
    end

    # Access MCMCChains functions using getfield
    summarystats_func = getfield(Main, :MCMCChains).summarystats
    quantile_func = getfield(Main, :MCMCChains).quantile

    try
        # Create chain including sigma if requested
        chain = results_to_chain(results; par_names=par_names, include_sigma=include_sigma, include_lp=true)

        # Calculate summary stats and quantiles
        stats = summarystats_func(chain)
        quants = quantile_func(chain; q=[lower, 0.5, upper])

        # Print nicely formatted summary
        println(stats)
        println("\nQuantiles ($(lower*100)% / 50% / $(upper*100)%):")
        println(quants)

        return (summarystats = stats, quantiles = quants)
    catch e
        @error "Error generating MCMCChains summary:" exception=(e, catch_backtrace())
        println("Falling back to basic mean/median calculation.")
        theta_mean = mean(results.theta, dims=1)
        theta_median = median(results.theta, dims=1)
        println("Theta Mean: ", round.(vec(theta_mean); digits=digits))
        println("Theta Median: ", round.(vec(theta_median); digits=digits))
        if include_sigma
             println("Sigma (Fixed/Optimized): ", round.(vec(results.sigma); digits=digits))
        end
         return nothing
    end
end


"""
    plot_magi(results::NamedTuple; type="traj", ...)

Generate plots from MagiSolver results. Requires Plots and StatsPlots to be loaded.
"""
function plot_magi(results::NamedTuple;
                   type="traj",
                   par_names=nothing,
                   comp_names=nothing,
                   t_obs=nothing,
                   y_obs=nothing,
                   obs=true,
                   ci=true,
                   ci_col=:skyblue,
                   lower=0.025,
                   upper=0.975,
                   include_sigma=false,
                   include_lp=true,
                   nplotcol=3,
                   kwargs...)

    # Check if plotting packages are loaded
    if !@isloaded(Plots) || !@isloaded(StatsPlots)
         error("Plots and StatsPlots packages are required for plotting. Please install and load them (`using Plots, StatsPlots`).")
    end

    # Access plotting functions using getfield
    Plots = getfield(Main, :Plots)
    StatsPlots = getfield(Main, :StatsPlots)

    if type == "traj"
        # --- Plot Trajectories ---
        x_sampled = results.x_sampled # [n_samples, n_times, n_dims]
        n_samples, n_times, n_dims = size(x_sampled)

        if comp_names === nothing
            _comp_names = ["Comp $i" for i in 1:n_dims]
        else
            if length(comp_names) != n_dims
                error("Length of comp_names ($(length(comp_names))) does not match number of dimensions ($n_dims).")
            end
            _comp_names = comp_names
        end

        # Determine plot layout
        plot_layout = (Int(ceil(n_dims / nplotcol)), nplotcol)
        plt = Plots.plot(layout=plot_layout, legend=false, titlefont=8; kwargs...)

        # Times for plotting x-axis
        plot_times = t_obs === nothing ? (1:n_times) : t_obs
        if length(plot_times) != n_times
             @warn "Length of provided t_obs ($(length(t_obs))) does not match trajectory length ($n_times). Using 1:$n_times for x-axis."
             plot_times = 1:n_times
        end
        xlab = t_obs === nothing ? "Index" : "Time"

        for d in 1:n_dims
            x_dim = x_sampled[:, :, d] # [n_samples, n_times]

            # Calculate mean and quantiles for credible interval
            x_mean = mean(x_dim, dims=1) |> vec
            # Use mapslices with try-catch for quantile robustness
            local x_lower, x_upper
            try
                x_lower = mapslices(x -> quantile(x, lower), x_dim, dims=1) |> vec
                x_upper = mapslices(x -> quantile(x, upper), x_dim, dims=1) |> vec
            catch e_quantile
                @warn "Could not calculate quantiles for trajectory plot CI for dim $d. CI disabled." exception=e_quantile
                ci = false # Disable CI for this dimension if quantile fails
                x_lower = x_mean # Assign dummy values
                x_upper = x_mean
            end

            # Add subplot for this dimension
            Plots.plot!(plt[d], plot_times, x_mean, linecolor=:blue, label="Mean",
                        xlabel=xlab, ylabel="Level", title=_comp_names[d])

            if ci # Check again in case it was disabled
                Plots.plot!(plt[d], plot_times, x_upper, fillrange=x_lower, fillalpha=0.3, fillcolor=ci_col,
                            linealpha=0, label="$((upper-lower)*100)% CI")
                # Plot boundaries faintly
                Plots.plot!(plt[d], plot_times, x_lower, linecolor=ci_col, linestyle=:dash, linealpha=0.5, label="")
                Plots.plot!(plt[d], plot_times, x_upper, linecolor=ci_col, linestyle=:dash, linealpha=0.5, label="")
            end

            # Overlay observations if requested
            if obs
                if y_obs === nothing || t_obs === nothing
                    @warn "Cannot plot observations for dimension $d because y_obs or t_obs was not provided to plot_magi."
                else
                     # Use try-catch for safety when accessing potentially mismatched y_obs
                     try
                         if size(y_obs) != (n_times, n_dims)
                             @warn "Dimensions of y_obs ($(size(y_obs))) do not match trajectory dimensions ($n_times, $n_dims). Cannot plot observations for dim $d."
                         else
                            valid_idx = findall(!isnan, y_obs[:, d])
                            if !isempty(valid_idx)
                                Plots.scatter!(plt[d], t_obs[valid_idx], y_obs[valid_idx, d],
                                               markercolor=:red, markersize=3, markerstrokewidth=0, label="Obs")
                            end
                         end
                     catch e_obs
                          @error "Error plotting observations for dimension $d." exception=e_obs
                     end
                end
            end
        end
        return plt

    elseif type == "trace"
        # --- Plot Traces ---
         if !@isloaded(MCMCChains)
             error("MCMCChains package is required for trace plots. Please install and load it (`using MCMCChains`).")
         end

        try
            # Ensure par_names is the right length if provided
            n_params_ode = size(results.theta, 2)

            # Validate parameter names length
            if par_names !== nothing && length(par_names) != n_params_ode
                @warn "Length of provided par_names ($(length(par_names))) does not match number of theta parameters ($n_params_ode). Using default names."
                par_names = nothing
            end

            # Create chain with appropriate parameters
            chain = results_to_chain(results; par_names=par_names, include_sigma=include_sigma, include_lp=include_lp)

            # Use StatsPlots directly now
            return StatsPlots.plot(chain; kwargs...)
        catch e
            @error "Error generating MCMCChains trace plot:" exception=(e, catch_backtrace())
            return nothing # Return empty plot on error
        end
    else
        error("Invalid plot type specified. Use type=\"traj\" or type=\"trace\".")
    end
end

end # End module MagiJl